\section{Message Definition -- PDU}
\label{sec:pdus}

In this section, we discuss the details of the \textsf{RCUC} protocol.

\subsection{Addressing}
\label{sec:pdus:addr}
\textsf{RCUC} protocol uses TCP/IP for transportation. It uses stream-oriented channels to send messages with no fixed sizes. [Note: We can customize port numbers to for specific task done by a device on the car. For example: We may want to assign base\_port\_number + device\_port\_index ex: 1010+1 = 1011 port no for air conditioner. ].

Based on port configuration we explained, a TCP connection is established to the \textsf{CCS} IP address and port number provided.
\subsection{Flow Control}
\label{sec:pdus:flow}
Flow control is dispatched to TCP/IP layer. [Note: As future extension, we may mention that we can enhance the flow control with adding asychrony in communication such as when client sends a message  and returns but sender send feedback later on. This reduces the congestion of network. In addition, we may buffer requests and flush them to server to save reduce communication overhead for each command.]
 
\subsection{PDU Definitions}
\label{sec:pdus:pdu}
\begin{itemize}
\item \textsf{Handshake}: is done via authentication.
\item \textsf{Utility Commands}: These are commands in between client and server. Client sends a command and waits for a response from server.
  \end{itemize}


PDU format is kept as generic as possible:
\[\textsf{CCS} \; | \; \textsf{C} \; : \; \textsf{Expr} \; | \; \textsf{ID} \; : \; \textsf{Size} \]
where \textsf{CCS} and \textsf{C} denotes whether message is sent by \textsf{CCS} server or client respectively. \textsf{Expr} and \textsf{ID} are data parts of the PDU chunks which represents either type/expression of the message, \textsf{Expr} or the unique device identifier, \textsf{ID}. \textsf{Size} is basically the number of bytesallocated for the message.

\subsubsection{Handshake}
\label{sec:pdus:pdu:hs}
\begin{itemize}
\item We assume that servers are already running. [Note: We can add one more phase for initialization of server but in that case ...]
\item When a client wants to connect to \textsf{CCS} server
  \[ \textsf{C} : \textsf{CON} : 1\]
\item We assume that there is a preset 1 byte password. \textsf{CSS} request for password with a 8 byte message. [Note: We can change and refine these messages.]
  \[\textsf{CSS} : \textsf{PASS} : 1\]
  \item Then client sends its passwords back to the server.[Note: we can use DES encrpytion in here]. 
    \[\textsf{C} : \textsf{SENDPASS} : 1\]
  \item If the response is incorrect, the server notifies with an error message and closes the connection:
    \[\textsf{CSS}:\textsf{ERROR}:1\]
    \item Otherwise \textsf{CCS} responds with start message
      \[\textsf{CSS} : \textsf{START} : 1\]
    \end{itemize}

\subsubsection{Client to Server Messages}
\label{sec:pdus:pdu:c_to_s}

After the connection is established which means client takes \textsf{START} messassage, client send command messages to server. 

Here how the message from client to server for a utility command packet looks like :

\[\textsf{C}:\textsf{COMMAND}:1\]
\[\textsf{C}:\textsf{DEVICETYPE}:1\]
\[\textsf{C}:\textsf{DEVICENUM}:1\]
\[\textsf{C}:\textsf{DEVICECOMMANDTYPE}:1\]
\[\textsf{C}:\textsf{VALUE}:1\]

where \textsf{COMMAND} denotes 
\subsubsection{Server to Client Messages}
\label{sec:pdus:pdu:s_to_c}

The server can update the client 
\subsection{Error Control}
\label{sec:pdus:err}

\input{pdus_qos}
